<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>T字路口｜黃燈＋左/右轉箭頭＋行人獨立相位</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#121a2b;
      --text:#e8eefc;
      --muted:#a9b6d6;
      --line:#2a3553;
      --good:#3cff7a;
      --bad:#ff3b3b;
      --warn:#ffd43b;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial;
      background: radial-gradient(1200px 800px at 30% 20%, #18234a 0%, var(--bg) 55%, #060a14 100%);
      color:var(--text);
      min-height:100vh;
      display:flex;
    }
    .wrap{
      width:min(1200px, 100%);
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:16px;
      align-items:start;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
      overflow:hidden;
    }
    .canvasWrap{ padding:12px; }

    /* ✅ 重要：給 canvas 明確高度，避免 Pages / grid 下 height:auto 變 0 */
    canvas{
      width:100%;
      height:600px;                 /* ⭐ 修正：讓畫面一定可見 */
      display:block;
      background: rgba(0,0,0,0.18);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
    }

    .panel{ padding:14px; background: rgba(0,0,0,0.12); }
    h1{ font-size:16px; margin:0 0 10px 0; letter-spacing:.4px; }
    .pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.18);
      font-size: 12px;
      color: var(--muted);
    }
    .dot{width:10px;height:10px;border-radius:50%;}
    .dot.green{background:var(--good)}
    .dot.red{background:var(--bad)}
    .dot.yellow{background:var(--warn)}
    .divider{ height:1px; background: rgba(255,255,255,0.10); margin: 12px 0; }
    .row{ display:flex; gap:10px; align-items:center; justify-content:space-between; margin:10px 0; }
    label{ font-size: 13px; color: var(--muted); }
    input[type="number"]{
      width: 130px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.22);
      color: var(--text);
      outline:none;
    }
    .btns{ display:flex; gap:10px; margin-top:12px; }
    button{
      flex:1;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.03));
      color: var(--text);
      cursor:pointer;
      font-weight: 600;
    }
    button:hover{filter:brightness(1.08)}
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      margin: 8px 0;
      font-size: 13px;
    }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }
    .small{ font-size: 12px; color: var(--muted); line-height: 1.6; margin-top: 10px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card canvasWrap">
      <canvas id="c"></canvas>
    </div>

    <div class="card panel">
      <h1>T 字路口｜黃燈＋支路左右轉箭頭燈＋行人獨立相位</h1>

      <div class="pill">
        <span class="dot green" id="phaseDot"></span>
        <span id="phaseText">Phase：左右直行綠</span>
      </div>

      <div class="divider"></div>

      <div class="row">
        <label>左右直行綠秒數（A_G）</label>
        <input type="number" id="tAG" min="5" max="120" value="16" />
      </div>
      <div class="row">
        <label>左右直行黃秒數（A_Y）</label>
        <input type="number" id="tAY" min="2" max="10" value="3" />
      </div>

      <div class="row">
        <label>支路左轉綠秒數（BL_G）</label>
        <input type="number" id="tBLG" min="5" max="120" value="8" />
      </div>
      <div class="row">
        <label>支路左轉黃秒數（BL_Y）</label>
        <input type="number" id="tBLY" min="2" max="10" value="2" />
      </div>

      <div class="row">
        <label>支路右轉綠秒數（BR_G）</label>
        <input type="number" id="tBRG" min="5" max="120" value="8" />
      </div>
      <div class="row">
        <label>支路右轉黃秒數（BR_Y）</label>
        <input type="number" id="tBRY" min="2" max="10" value="2" />
      </div>

      <div class="row">
        <label>行人通行秒數（P_WALK）</label>
        <input type="number" id="tPW" min="5" max="60" value="10" />
      </div>

      <div class="row">
        <label>全紅緩衝秒數（All-Red）</label>
        <input type="number" id="tR" min="1" max="15" value="2" />
      </div>

      <div class="row">
        <label>車流生成率（0~1）</label>
        <input type="number" id="spawn" min="0" max="1" step="0.05" value="0.45" />
      </div>

      <div class="btns">
        <button id="toggle">暫停</button>
        <button id="reset">重置</button>
      </div>

      <div class="divider"></div>

      <div class="kv">
        <div>左右車燈</div><div class="mono" id="sigLR">GREEN</div>
      </div>
      <div class="kv">
        <div>支路直/黃/紅</div><div class="mono" id="sigBMain">RED</div>
      </div>
      <div class="kv">
        <div>支路左箭頭</div><div class="mono" id="sigBLeft">RED</div>
      </div>
      <div class="kv">
        <div>支路右箭頭</div><div class="mono" id="sigBRight">RED</div>
      </div>
      <div class="kv">
        <div>行人</div><div class="mono" id="sigPed">STOP</div>
      </div>
      <div class="kv">
        <div>本相位剩餘秒</div><div class="mono" id="count">16</div>
      </div>

      <p class="small">
        相位流程：A_G → A_Y → 全紅 → BL_G → BL_Y → 全紅 → BR_G → BR_Y → 全紅 → 行人通行 → 全紅 → 循環。<br/>
        行人相位時：所有車輛全紅，三條斑馬線都顯示 WALK。
      </p>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const ui = {
    tAG: document.getElementById('tAG'),
    tAY: document.getElementById('tAY'),
    tBLG: document.getElementById('tBLG'),
    tBLY: document.getElementById('tBLY'),
    tBRG: document.getElementById('tBRG'),
    tBRY: document.getElementById('tBRY'),
    tPW: document.getElementById('tPW'),
    tR: document.getElementById('tR'),
    spawn: document.getElementById('spawn'),
    toggle: document.getElementById('toggle'),
    reset: document.getElementById('reset'),

    phaseText: document.getElementById('phaseText'),
    phaseDot: document.getElementById('phaseDot'),

    sigLR: document.getElementById('sigLR'),
    sigBMain: document.getElementById('sigBMain'),
    sigBLeft: document.getElementById('sigBLeft'),
    sigBRight: document.getElementById('sigBRight'),
    sigPed: document.getElementById('sigPed'),
    count: document.getElementById('count'),
  };

  // ✅ 讓 canvas 的「繪圖尺寸」跟著 CSS 尺寸走（避免只看到背景）
  function resizeCanvasToCSS() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();

    const newW = Math.max(1, Math.round(rect.width * dpr));
    const newH = Math.max(1, Math.round(rect.height * dpr));

    if (canvas.width !== newW || canvas.height !== newH) {
      canvas.width = newW;
      canvas.height = newH;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // 用 CSS 像素繪圖
    }
  }

  // Geometry computed from current canvas CSS size
  function getGeom() {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width;
    const H = rect.height;

    const road = {
      y: Math.round(H * 0.38),
      h: 140,
      x: Math.round(W * 0.52),
      w: 150,
    };
    const intersection = {
      x0: road.x - road.w/2,
      x1: road.x + road.w/2,
      y0: road.y - road.h/2,
      y1: road.y + road.h/2,
    };
    return { W, H, road, intersection };
  }

  const SIG = { RED:'RED', YELLOW:'YELLOW', GREEN:'GREEN' };

  const PH = {
    A_G: 'A_G', A_Y: 'A_Y', AR1: 'AR1',
    BL_G: 'BL_G', BL_Y: 'BL_Y', AR2: 'AR2',
    BR_G: 'BR_G', BR_Y: 'BR_Y', AR3: 'AR3',
    P_WALK: 'P_WALK', AR4: 'AR4',
  };

  let phase = PH.A_G;
  let remaining = 0;

  function clampInt(v,min,max){
    const n = Math.round(Number(v)||0);
    return Math.max(min, Math.min(max, n));
  }
  function getDur(){
    return {
      AG: clampInt(ui.tAG.value, 5, 120),
      AY: clampInt(ui.tAY.value, 2, 10),
      BLG: clampInt(ui.tBLG.value, 5, 120),
      BLY: clampInt(ui.tBLY.value, 2, 10),
      BRG: clampInt(ui.tBRG.value, 5, 120),
      BRY: clampInt(ui.tBRY.value, 2, 10),
      PW: clampInt(ui.tPW.value, 5, 60),
      R: clampInt(ui.tR.value, 1, 15),
    };
  }

  function nextPhase(ph){
    switch(ph){
      case PH.A_G: return PH.A_Y;
      case PH.A_Y: return PH.AR1;
      case PH.AR1: return PH.BL_G;

      case PH.BL_G: return PH.BL_Y;
      case PH.BL_Y: return PH.AR2;
      case PH.AR2: return PH.BR_G;

      case PH.BR_G: return PH.BR_Y;
      case PH.BR_Y: return PH.AR3;
      case PH.AR3: return PH.P_WALK;

      case PH.P_WALK: return PH.AR4;
      default: return PH.A_G;
    }
  }

  function durationForPhase(ph, d){
    switch(ph){
      case PH.A_G: return d.AG;
      case PH.A_Y: return d.AY;
      case PH.AR1:
      case PH.AR2:
      case PH.AR3:
      case PH.AR4: return d.R;
      case PH.BL_G: return d.BLG;
      case PH.BL_Y: return d.BLY;
      case PH.BR_G: return d.BRG;
      case PH.BR_Y: return d.BRY;
      case PH.P_WALK: return d.PW;
      default: return d.R;
    }
  }

  function signalsForPhase(ph){
    const allRed = { LR:SIG.RED, BMain:SIG.RED, BLeft:SIG.RED, BRight:SIG.RED, Ped:'STOP' };

    if (ph === PH.P_WALK) return { ...allRed, Ped:'WALK' };

    if (ph === PH.A_G) return { LR:SIG.GREEN,  BMain:SIG.RED, BLeft:SIG.RED,   BRight:SIG.RED,   Ped:'STOP' };
    if (ph === PH.A_Y) return { LR:SIG.YELLOW, BMain:SIG.RED, BLeft:SIG.RED,   BRight:SIG.RED,   Ped:'STOP' };

    if (ph === PH.BL_G) return { LR:SIG.RED, BMain:SIG.RED, BLeft:SIG.GREEN,  BRight:SIG.RED,   Ped:'STOP' };
    if (ph === PH.BL_Y) return { LR:SIG.RED, BMain:SIG.RED, BLeft:SIG.YELLOW, BRight:SIG.RED,   Ped:'STOP' };

    if (ph === PH.BR_G) return { LR:SIG.RED, BMain:SIG.RED, BLeft:SIG.RED,    BRight:SIG.GREEN, Ped:'STOP' };
    if (ph === PH.BR_Y) return { LR:SIG.RED, BMain:SIG.RED, BLeft:SIG.RED,    BRight:SIG.YELLOW,Ped:'STOP' };

    return allRed;
  }

  function resetMachine(){
    phase = PH.A_G;
    remaining = durationForPhase(phase, getDur());
  }

  // Cars
  const cars = [];
  const CAR_W = 22, CAR_H = 14;

  function rnd(a,b){ return a + Math.random()*(b-a); }

  function spawnCar(geom){
    const p = Number(ui.spawn.value);
    if (Math.random() > p) return;

    const { W, H, road } = geom;
    const r = Math.random();

    if (r < 0.38){
      cars.push({ type:'LR', x:-40, y: road.y + 18, vx:rnd(90,130), vy:0, w:CAR_W, h:CAR_H });
    } else if (r < 0.76){
      cars.push({ type:'RL', x:W+40, y: road.y - 18, vx:-rnd(90,130), vy:0, w:CAR_W, h:CAR_H });
    } else {
      const turn = Math.random()<0.5 ? 'toL' : 'toR';
      cars.push({ type:'B', turn, x: road.x + 18, y:H+40, vx:0, vy:-rnd(85,120), w:CAR_H, h:CAR_W, turned:false });
    }
  }

  function stopLineFor(car, geom){
    const { intersection } = geom;
    const margin = 20;
    if (car.type === 'LR') return intersection.x0 - margin;
    if (car.type === 'RL') return intersection.x1 + margin;
    return intersection.y1 + margin;
  }

  function isPastStopLine(car, geom){
    const s = stopLineFor(car, geom);
    if (car.type === 'LR') return car.x > s;
    if (car.type === 'RL') return car.x < s;
    return car.y < s;
  }

  function willEnterIntersection(car, geom){
    const s = stopLineFor(car, geom);
    if (car.type === 'LR') return car.x + car.w/2 >= s - 2;
    if (car.type === 'RL') return car.x - car.w/2 <= s + 2;
    return car.y - car.h/2 <= s + 2;
  }

  function canProceedForCar(car, sig, geom){
    if (sig.Ped === 'WALK') return false;

    if (car.type === 'LR' || car.type === 'RL'){
      if (sig.LR === SIG.GREEN) return true;
      if (sig.LR === SIG.YELLOW) return isPastStopLine(car, geom);
      return false;
    }

    const arrow = (car.turn === 'toL') ? sig.BLeft : sig.BRight;
    if (arrow === SIG.GREEN) return true;
    if (arrow === SIG.YELLOW) return isPastStopLine(car, geom);
    return false;
  }

  function updateCars(dt, sig, geom){
    for (const car of cars){
      const approaching = willEnterIntersection(car, geom) && !isPastStopLine(car, geom);
      const allowed = canProceedForCar(car, sig, geom);
      const shouldStop = approaching && !allowed;

      if (!shouldStop){
        car.x += car.vx * dt;
        car.y += car.vy * dt;
      }

      if (car.type === 'B' && !car.turned){
        const { road } = geom;
        if (car.y <= road.y + 10){
          car.turned = true;
          const sp = Math.abs(car.vy);
          if (car.turn === 'toL'){
            car.vx = -sp; car.vy = 0;
            car.y = road.y - 18;
            car.w = CAR_W; car.h = CAR_H;
          } else {
            car.vx = sp; car.vy = 0;
            car.y = road.y + 18;
            car.w = CAR_W; car.h = CAR_H;
          }
        }
      }
    }

    const { W, H } = geom;
    for (let i=cars.length-1; i>=0; i--){
      const car = cars[i];
      if (car.x < -140 || car.x > W+140 || car.y < -140 || car.y > H+140){
        cars.splice(i,1);
      }
    }
  }

  // Drawing helpers
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  function dashedLine(x1,y1,x2,y2){
    ctx.save();
    ctx.setLineDash([16, 10]);
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    ctx.restore();
  }

  function drawZebra(x,y,w,h,dir){
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    const stripe = 6, gap = 6;
    if (dir === 'vertical'){
      for (let yy=y; yy<y+h; yy += stripe+gap) ctx.fillRect(x, yy, w, stripe);
    } else {
      for (let xx=x; xx<x+w; xx += stripe+gap) ctx.fillRect(xx, y, stripe, h);
    }
    ctx.restore();
  }

  function drawRoad(geom){
    const { W, H, road, intersection } = geom;
    ctx.clearRect(0,0,W,H);

    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(0, road.y-road.h/2, W, road.h);
    ctx.fillRect(road.x-road.w/2, road.y, road.w, H-road.y);

    ctx.strokeStyle = 'rgba(255,255,255,0.16)';
    ctx.lineWidth = 2;
    dashedLine(0, road.y, W, road.y);
    dashedLine(road.x, road.y, road.x, H);

    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 3;
    ctx.strokeRect(0, road.y-road.h/2, W, road.h);
    ctx.strokeRect(road.x-road.w/2, road.y, road.w, H-road.y);

    drawZebra(intersection.x0 - 55, road.y-road.h/2 + 8, 42, road.h-16, 'vertical');
    drawZebra(intersection.x1 + 13, road.y-road.h/2 + 8, 42, road.h-16, 'vertical');
    drawZebra(road.x-road.w/2 + 8, intersection.y1 + 14, road.w-16, 42, 'horizontal');

    ctx.strokeStyle = 'rgba(255,255,255,0.60)';
    ctx.lineWidth = 4;

    ctx.beginPath();
    ctx.moveTo(intersection.x0-20, road.y+road.h/2-6);
    ctx.lineTo(intersection.x0-20, road.y+6);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(intersection.x1+20, road.y-road.h/2+6);
    ctx.lineTo(intersection.x1+20, road.y-6);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(road.x-road.w/2+6, intersection.y1+20);
    ctx.lineTo(road.x+road.w/2-6, intersection.y1+20);
    ctx.stroke();

    ctx.fillStyle = 'rgba(232,238,252,0.75)';
    ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
    ctx.fillText('左來車 →', 18, road.y + 55);
    ctx.fillText('← 右來車', W-92, road.y - 45);
    ctx.fillText('下方來車（左/右轉需箭頭）', road.x - 110, H-18);
  }

  function lampColor(onColor, isOn){
    return isOn ? onColor : 'rgba(255,255,255,0.12)';
  }

  function drawLight3(x,y,state){
    ctx.save();
    ctx.translate(x,y);
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    roundRect(-14,-26,28,52,8);
    ctx.fill();

    const lamps = [
      { cy:-14, on: state===SIG.RED,    col:'rgba(255,70,70,1)' },
      { cy:  0, on: state===SIG.YELLOW, col:'rgba(255,210,60,1)' },
      { cy: 14, on: state===SIG.GREEN,  col:'rgba(60,255,140,1)' },
    ];
    for (const l of lamps){
      ctx.beginPath();
      ctx.arc(0,l.cy,7,0,Math.PI*2);
      ctx.fillStyle = lampColor(l.col, l.on);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawArrowLamp(x,y,state,dir){
    ctx.save();
    ctx.translate(x,y);
    ctx.beginPath();
    ctx.arc(0,0,7,0,Math.PI*2);
    const on = (state===SIG.GREEN || state===SIG.YELLOW);
    const col = (state===SIG.GREEN)
      ? 'rgba(60,255,140,1)'
      : (state===SIG.YELLOW ? 'rgba(255,210,60,1)' : 'rgba(255,255,255,0.12)');
    ctx.fillStyle = col;
    ctx.fill();

    if (on){
      ctx.strokeStyle = 'rgba(0,0,0,0.55)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      if (dir === 'L'){
        ctx.moveTo(3,-3); ctx.lineTo(-2,0); ctx.lineTo(3,3);
        ctx.moveTo(-2,0); ctx.lineTo(4,0);
      } else {
        ctx.moveTo(-3,-3); ctx.lineTo(2,0); ctx.lineTo(-3,3);
        ctx.moveTo(-4,0); ctx.lineTo(2,0);
      }
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawBottomSignal(x,y,main,left,right){
    ctx.save();
    ctx.translate(x,y);
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    roundRect(-18,-34,36,68,10);
    ctx.fill();

    ctx.beginPath(); ctx.arc(0,-18,7,0,Math.PI*2);
    ctx.fillStyle = lampColor('rgba(255,70,70,1)', main===SIG.RED);
    ctx.fill();

    ctx.beginPath(); ctx.arc(0,0,7,0,Math.PI*2);
    ctx.fillStyle = lampColor('rgba(255,210,60,1)', main===SIG.YELLOW);
    ctx.fill();

    ctx.beginPath(); ctx.arc(0,18,7,0,Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.10)';
    ctx.fill();

    drawArrowLamp(-12, 18, left, 'L');
    drawArrowLamp( 12, 18, right,'R');

    ctx.restore();
  }

  function drawPedLight(x,y,walk){
    ctx.save();
    ctx.translate(x,y);
    ctx.fillStyle = 'rgba(0,0,0,0.42)';
    roundRect(-16,-14,32,28,10);
    ctx.fill();

    ctx.font = '12px ui-monospace, Menlo, Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = walk ? 'rgba(60,255,140,0.95)' : 'rgba(255,70,70,0.95)';
    ctx.fillText(walk ? 'WALK' : 'STOP', 0, 0);
    ctx.restore();
  }

  function drawCountdownBox(x,y,sec){
    ctx.save();
    ctx.translate(x,y);
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    roundRect(-36,-18,72,36,12);
    ctx.fill();

    ctx.fillStyle = 'rgba(232,238,252,0.95)';
    ctx.font = '16px ui-monospace, Menlo, Consolas, monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(sec).padStart(2,'0'), 0, 1);
    ctx.restore();
  }

  function drawSignals(sig, geom){
    const { road, intersection } = geom;

    const Lpos = { x: intersection.x0-34, y: road.y+road.h/2-30 };
    const Rpos = { x: intersection.x1+34, y: road.y-road.h/2+30 };
    drawLight3(Lpos.x, Lpos.y, sig.LR);
    drawLight3(Rpos.x, Rpos.y, sig.LR);

    const Bpos = { x: road.x+road.w/2-26, y: intersection.y1+52 };
    let main = SIG.RED;
    if (sig.BLeft === SIG.YELLOW || sig.BRight === SIG.YELLOW) main = SIG.YELLOW;
    drawBottomSignal(Bpos.x, Bpos.y, main, sig.BLeft, sig.BRight);

    drawCountdownBox(road.x - 34, road.y - 60, remaining);

    const walk = (sig.Ped === 'WALK');
    drawPedLight(intersection.x0 - 65, road.y - 70, walk);
    drawPedLight(intersection.x1 + 65, road.y + 70, walk);
    drawPedLight(road.x - 95, intersection.y1 + 70, walk);
  }

  function drawCars(){
    for (const car of cars){
      ctx.save();
      ctx.translate(car.x, car.y);

      if (car.type === 'LR') {}
      else if (car.type === 'RL') ctx.rotate(Math.PI);
      else if (car.type === 'B') ctx.rotate(-Math.PI/2);

      ctx.fillStyle = 'rgba(120,200,255,0.95)';
      ctx.fillRect(-car.w/2, -car.h/2, car.w, car.h);

      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(-car.w/2 + 4, -car.h/2 + 3, car.w*0.4, car.h-6);

      ctx.fillStyle = 'rgba(255,80,80,0.8)';
      ctx.fillRect(car.w/2 - 4, -car.h/2 + 3, 3, car.h-6);

      ctx.restore();
    }
  }

  function phaseLabel(ph){
    switch(ph){
      case PH.A_G: return ['左右直行綠（A_G）', 'green'];
      case PH.A_Y: return ['左右直行黃（A_Y）', 'yellow'];
      case PH.BL_G: return ['支路左轉綠箭頭（BL_G）', 'green'];
      case PH.BL_Y: return ['支路左轉黃箭頭（BL_Y）', 'yellow'];
      case PH.BR_G: return ['支路右轉綠箭頭（BR_G）', 'green'];
      case PH.BR_Y: return ['支路右轉黃箭頭（BR_Y）', 'yellow'];
      case PH.P_WALK: return ['行人通行（P_WALK）', 'green'];
      default: return ['全紅緩衝（All-Red）', 'red'];
    }
  }

  function updateUI(sig){
    const [txt, color] = phaseLabel(phase);
    ui.phaseText.textContent = 'Phase：' + txt;
    ui.phaseDot.className = 'dot ' + color;

    ui.sigLR.textContent = sig.LR;
    ui.sigBMain.textContent = (sig.BLeft===SIG.GREEN||sig.BRight===SIG.GREEN) ? 'RED(僅箭頭)' :
                              (sig.BLeft===SIG.YELLOW||sig.BRight===SIG.YELLOW) ? 'YELLOW(僅箭頭)' : 'RED';
    ui.sigBLeft.textContent = sig.BLeft;
    ui.sigBRight.textContent = sig.BRight;
    ui.sigPed.textContent = sig.Ped;
    ui.count.textContent = remaining;
  }

  let running = true;
  let acc = 0;
  let last = performance.now();

  function step(now){
    resizeCanvasToCSS();
    const geom = getGeom();

    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    if (running){
      acc += dt;
      while (acc >= 1){
        acc -= 1;
        remaining -= 1;

        if (remaining <= 0){
          const d = getDur();
          phase = nextPhase(phase);
          remaining = durationForPhase(phase, d);
        }
      }
      if (Math.random() < dt * 3.0) spawnCar(geom);
    }

    const sig = signalsForPhase(phase);
    if (running) updateCars(dt, sig, geom);

    drawRoad(geom);
    drawSignals(sig, geom);
    drawCars();
    updateUI(sig);

    requestAnimationFrame(step);
  }

  ui.toggle.addEventListener('click', () => {
    running = !running;
    ui.toggle.textContent = running ? '暫停' : '繼續';
  });

  ui.reset.addEventListener('click', () => {
    cars.length = 0;
    resetMachine();
  });

  function softApply(){
    const d = getDur();
    remaining = Math.min(remaining, durationForPhase(phase, d));
  }
  for (const el of [ui.tAG,ui.tAY,ui.tBLG,ui.tBLY,ui.tBRG,ui.tBRY,ui.tPW,ui.tR]){
    el.addEventListener('change', softApply);
  }

  window.addEventListener('resize', () => {
    resizeCanvasToCSS();
  });

  resetMachine();
  resizeCanvasToCSS();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
